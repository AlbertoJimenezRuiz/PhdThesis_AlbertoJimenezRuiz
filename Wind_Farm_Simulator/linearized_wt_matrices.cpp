#include "linearized_wt_matrices.h"
#include "main.h"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-conversion"

double function_wr_initial_value(const wt_parameters_struct &wt, double omega_t,
                                 FLOATING_TYPE input[4]) {
  const double omega_r = omega_t;
  (void)omega_r;
  double res;
#include "autogenerated/wr_iterate_value.h"
  return res;
}

double function_wr_initial_value_derivative(const wt_parameters_struct &wt,
                                            double omega_t,
                                            FLOATING_TYPE input[4]) {
  const double omega_r = omega_t;
  (void)omega_r;
  double res;
#include "autogenerated/wr_derivative_iterate_value.h"
  return res;
}

void get_initial_value(const wt_parameters_struct &wt, FLOATING_TYPE input[4],
                       double omega_t, FLOATING_TYPE *initial_value) {
  const double omega_r = omega_t;
  (void)omega_r;
#include "autogenerated/initial_value_substitution.h"
}

void generate_matrices(const wt_parameters_struct &wt, FLOATING_TYPE *MatA,
                       FLOATING_TYPE *MatB, FLOATING_TYPE *MatC,
                       FLOATING_TYPE *MatD, FLOATING_TYPE *state,
                       FLOATING_TYPE *input, FLOATING_TYPE *output) {
  int number_states, number_inputs, number_outputs;
  {
#include "autogenerated/Matrices_ABCD.h"
  }

  {
#include "autogenerated/MatrY0.h"
  }

  (void)number_states;
  (void)number_inputs;
  (void)number_outputs;

  assert(number_states == NUMBER_X_EQUATIONS);
  assert(number_inputs == NUMBER_U_VALUES);
  assert(number_outputs == NUMBER_Y_EQUATIONS);
}

bool almost_zero_wt_matrices(FLOATING_TYPE x) { return std::abs(x) < 1E-7; }

int sgn(FLOATING_TYPE x) {
  if (x < 0) {
    return -1;
  }

  if (x > 0) {
    return 1;
  }
  return 0;
}

Linearized_Matrices_WT::Linearized_Matrices_WT() : parameters(NULL) {
  MatrA = NULL;
  MatrB = NULL;
  MatrC = NULL;
  MatrD = NULL;
  MatrU0 = NULL;
  MatrX0 = NULL;
  MatrY0 = NULL;
}

Linearized_Matrices_WT::Linearized_Matrices_WT(
    const wt_parameters_struct *param, FLOATING_TYPE usd_current,
    FLOATING_TYPE usq_current, FLOATING_TYPE desired_reactive_current,
    FLOATING_TYPE uw_current)
    : parameters(param) {
  size_matrix_A =
      (int)sizeof(FLOATING_TYPE) * NUMBER_X_EQUATIONS * NUMBER_X_EQUATIONS;
  size_matrix_B =
      (int)sizeof(FLOATING_TYPE) * NUMBER_X_EQUATIONS * NUMBER_U_VALUES;
  size_matrix_C =
      (int)sizeof(FLOATING_TYPE) * NUMBER_Y_EQUATIONS * NUMBER_X_EQUATIONS;
  size_matrix_D =
      (int)sizeof(FLOATING_TYPE) * NUMBER_Y_EQUATIONS * NUMBER_U_VALUES;
  size_matrix_U0 = (int)sizeof(FLOATING_TYPE) * NUMBER_U_VALUES;
  size_matrix_X0 = (int)sizeof(FLOATING_TYPE) * NUMBER_X_EQUATIONS;
  size_matrix_Y0 = (int)sizeof(FLOATING_TYPE) * NUMBER_Y_EQUATIONS;

  MatrA = (FLOATING_TYPE *)malloc(size_matrix_A);
  MatrB = (FLOATING_TYPE *)malloc(size_matrix_B);
  MatrC = (FLOATING_TYPE *)malloc(size_matrix_C);
  MatrD = (FLOATING_TYPE *)malloc(size_matrix_D);
  MatrU0 = (FLOATING_TYPE *)malloc(size_matrix_U0);
  MatrX0 = (FLOATING_TYPE *)malloc(size_matrix_X0);
  MatrY0 = (FLOATING_TYPE *)malloc(size_matrix_Y0);

  memset(MatrA, 0, size_matrix_A);
  memset(MatrB, 0, size_matrix_B);
  memset(MatrC, 0, size_matrix_C);
  memset(MatrD, 0, size_matrix_D);
  memset(MatrU0, 0, size_matrix_U0);
  memset(MatrX0, 0, size_matrix_X0);
  memset(MatrY0, 0, size_matrix_Y0);

  MatrU0[0] = usd_current;
  MatrU0[1] = usq_current;
  MatrU0[2] = desired_reactive_current;
  MatrU0[3] = uw_current;

  const double step_range_search_speed = 0.01;

  double limit_inferior = 1.0 - step_range_search_speed;
  double limit_superior = 1.0 + step_range_search_speed;

  // sweep velocity from 0.0 to 2.0
  for (double wr_min = 0; wr_min < 2.0; wr_min += step_range_search_speed) {
    double wr_max = wr_min + step_range_search_speed;

    double wr_min_val = function_wr_initial_value(*param, wr_min, MatrU0);
    double wr_max_val = function_wr_initial_value(*param, wr_max, MatrU0);

    if (almost_zero_wt_matrices(wr_min_val) ||
        almost_zero_wt_matrices(wr_max_val) ||
        (sgn(wr_min_val) != sgn(wr_max_val))) {
      limit_inferior = wr_min;
      limit_superior = wr_max;
    }
  }

  const int max_approximations =
      10000; // Maximum number of Newton-Raphson iterations

  double omega_t_iteration =
      ((double)(limit_inferior + limit_superior)) / (2.0); // First iteration

  for (int i = 0; i < max_approximations; i++) {
    // Slowed down Newton-Raphson
    auto offset_new_newton_raphson_iteration =
        0.01 * function_wr_initial_value(*param, omega_t_iteration, MatrU0) /
        function_wr_initial_value_derivative(*param, omega_t_iteration, MatrU0);
    omega_t_iteration -= offset_new_newton_raphson_iteration;

    if (almost_zero_wt_matrices(offset_new_newton_raphson_iteration))
      break;
  }

  get_initial_value(*param, MatrU0, omega_t_iteration, MatrX0);
  generate_matrices(*param, MatrA, MatrB, MatrC, MatrD, MatrX0, MatrU0, MatrY0);
}

Linearized_Matrices_WT::~Linearized_Matrices_WT() {
  free(MatrA);
  free(MatrB);
  free(MatrC);
  free(MatrD);
  free(MatrU0);
  free(MatrX0);
  free(MatrY0);
}

#pragma GCC diagnostic pop
